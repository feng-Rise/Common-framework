

https://www.topgoer.cn/docs/ginkuangjia/ginkuangjia-1c50hfaag99k2 文档
https://www.cnblogs.com/yjf512/p/9670990.html
https://www.liwenzhou.com/posts/Go/read_gin_sourcecode/ 路由
https://blog.csdn.net/qq_39401252/article/details/123468153 http路由和gin的区别

#### Gin框架优点

- 快速：基于 Radix 树的路由,性能非常强大。
- 支持中间件：内置许多中间件，如 Logger,Gzip,Authorization 等。
- 崩溃恢复：可以捕捉 panic 引发的程序崩溃，使 Web 服务可以一直运行。
- JSON 验证：可以验证请求中 JSON 数据格式。
- 多种数据渲染方式：支持 HTML、JSON、YAML、XML 等数据格式的响应。
- 扩展性：非常简单扩展中间件。

http库只是基本的架子，还缺少很多问题。Gin进一步封装，让我们能更快使用——比如，http中的http.Request.Body只会读一次，第二次是读不到的，然后你使用的话需要自己保存；但是用Gin后，它会帮你做好保存让你直接使用，这样更加符合开发的逻辑。总之，Gin就是弥补了原生http库的不足，并且这些补充都是适用了的最佳实践方式。

go 的 http请求流程是 bind listen accpet 之后创建了一个groutine，这个groutine去处理对应的业务，其中 server中有handle接口，在listenandserver中指定了这个handle，外部用一个结构体实现这个hanle接口，这个接口里面有这个severhttp方法，去处理对应的请求，如果没有指定，那么http库默认会走defalutseverrmux，这个结构体实现了handle接口，结构体内部有路由，通过map来实现的

对于gin框架来说通过enginee实现的servehttp方法，来实现的请求的读取和返回结果，在gin的serverhttp中 通过临时对象池创建了contexrt，context内部封装了，request，response

```go
r := gin.Default()//1.初始化了相关的参数 2.将路由及处理handler注册到路由树中 3.启动服务
```

```go
func ListenAndServe(addr string, handler Handler) error {   
    server := &Server{Addr: addr, Handler: handler
    return server.ListenAndServe() 
}    
```

```go
type Handler interface {   
	ServeHTTP(ResponseWriter, *Request) 
}
//gin框架入口也就是在这里 Engine结构体会实现这个方法成为接口类型
```

```go
func (engine *Engine) ServeHTTP(w http.ResponseWriter, req *http.Request) {   
    c := engine.pool.Get().(*Context)   
    c.writermem.reset(w)   
    c.Request = req   
    c.reset()   
    engine.handleHTTPRequest(c)   
    engine.pool.Put(c) 
}
//http.ResponseWriter和http.Request被封装在了context 从临时对象池中获取
```
